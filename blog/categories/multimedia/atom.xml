<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Multimedia | The Place Where Wishes Come True]]></title>
  <link href="http://jellyflower.github.io/blog/categories/multimedia/atom.xml" rel="self"/>
  <link href="http://jellyflower.github.io/"/>
  <updated>2014-08-11T22:34:50-04:00</updated>
  <id>http://jellyflower.github.io/</id>
  <author>
    <name><![CDATA[Jellyflower]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to Use 64-bit X264 With 32-bit AviSynth]]></title>
    <link href="http://jellyflower.github.io/blog/2013/03/09/how-to-use-64-bit-x264-with-32-bit-avisynth/"/>
    <updated>2013-03-09T18:40:00-05:00</updated>
    <id>http://jellyflower.github.io/blog/2013/03/09/how-to-use-64-bit-x264-with-32-bit-avisynth</id>
    <content type="html"><![CDATA[<p>For some reason I had to use AviSynth 2.6, of which I could’t seem to find a 64-bit build. But I did’t want to use 32-bit x264, because the 64-bit version had much better performance on 64-bit machines.</p>

<p>After some research, I found avs2pipemod. avs2pipemod is a program that pipes the output of AviSynth to other programs, with which we are able to connect 64-bit x264 and 32-bit AviSynth.</p>

<p>Because we will be piping raw video, we have to specify the parameters of the video manually. Fortunately avs2pipemod is able to generate those arguments for us. First we execute the following command:</p>

<pre><code>avs2pipemod -x264raw SCRIPT.avs
</code></pre>

<p>And we will get something like this:</p>

<pre><code>- --demuxer raw --input-csp bgr --input-depth 8 --input-res 1920x1080 --output-csp rgb --frames 24429 --fps 30030/1001
</code></pre>

<p>Of course the values will change depending on your source. So now we can call x264 with those arguments</p>

<pre><code>avs2pipemod -rawvideo SCRIPT.avs | x264 - --demuxer raw --input-csp bgr --input-depth 8 --input-res 1920x1080 --frames 24429 --fps 30030/1001 --preset veryslow --crf 23 -o OUTPUT.mkv
</code></pre>

<p>It’s just copying the arguments generated by the first command, plus the arguments you would like to use for encoding.</p>

<p>For some reason when I tried this, I got my encoded video upside down. I am not quite clear what caused that. However the problem can be easily solved by changing the previous command a little bit:</p>

<pre><code>avs2pipemod -rawvideo=vflip SCRIPT.avs | ...
</code></pre>

<p>The x264 part remains the same. I only tried once, so I don’t know if this happens to just some or all videos. You definitely want to check your result to know if it is necessary for you to use vflip.</p>

<p>So far we’ve done the video part. For audio, use the following command:</p>

<pre><code>avs2pipemod -wav SCRIPT.avs | flac -8V -o OUTPUT.flac -
</code></pre>

<p>Here we are piping the audio in WAV format, therefore we don’t need to specify the parameters of the audio. Of course you can use whatever encoder you want.</p>

<p>Now just mux the two streams and you are good to go.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[黑客如何给 B 站投稿]]></title>
    <link href="http://jellyflower.github.io/blog/2013/02/12/the-way-a-hacker-submits-video-to-bilibili/"/>
    <updated>2013-02-12T00:03:00-05:00</updated>
    <id>http://jellyflower.github.io/blog/2013/02/12/the-way-a-hacker-submits-video-to-bilibili</id>
    <content type="html"><![CDATA[<p>今天一时兴起给哔哩哔哩投稿，研究了一下发现还真有些门道。这里把我的研究成果发出来，起到抛玉引砖的作用。（是的我的方法是最好的，你的方法只能是砖。）</p>

<p>众所周知，哔哩哔哩并没有自己的服务器，其视频全部是盗链其他的视频站。按目前的状况，用新浪视频是最好的选择。</p>

<p>使用新浪视频，一个问题是审核，貌似现在新浪视频是先发后审。所以你的视频要能存活一天才能说是过了审核。但偶尔也有两三天后被和谐的。</p>

<p>至于过审核没什么技巧，视频标题胡乱填，别的信息能不填就不填，一般来说问题不大。</p>

<p>最大的问题是，新浪视频会不分青红皂白把你上传的视频重编码。重编码的结果往往是渣画质和渣音质。所以哔哩哔哩众把新浪视频称为“渣浪”。而我们的目的就是要防止视频被重编码，就是所谓的“战渣浪”。</p>

<!-- more -->


<p>Surround your pullquote like this {&#8221; text to be quoted &#8220;}</p>

<p>其实你被我骗了，上面这条只是最重要的一条。其他还要注意，容器格式只能是 FLV，其中包含 AVC 编码的视频流和 AAC 编码的音频流。AVC 和 AAC 编码有很多 profiles 啊什么的，我没有具体测试支持哪些。</p>

<p>所以可以先看看要上传的文件，如果比特率和编码格式达到要求，恭喜你，不用重编码了。只用确保容器是 FLV 就可以上传了。换容器可以用 FFmpeg 很简单的办到：</p>

<pre><code>ffmpeg -i INPUT -vcodec copy -acodec copy OUTPUT
</code></pre>

<p>要重编码的话，我们就得规划一下，音频流的比特率 ~ 140 Kib/s 左右足矣，然后视频流就 ~ 800 Kib/s 吧。</p>

<p>编码视频用 x264：</p>

<pre><code>x264 INPUT -o video.mkv --pass 1 --bitrate 800
x264 INPUT -o video.mkv --pass 2 --bitrate 800
</code></pre>

<p>Surround your pullquote like this {&#8221; text to be quoted &#8220;}</p>

<p>音频部分要先抽出原视频的音频：</p>

<pre><code>ffmpeg -i INPUT -vn -acodec pcm_s32le -ac 2 audio.wav
</code></pre>

<p>然后用 Nero AAC Codec 编码：</p>

<pre><code>neroaacenc -q 0.4 -lc -ignorelength -if audio.wav -of audio.m4a
</code></pre>

<p>最后 mux 就行了：</p>

<pre><code>ffmpeg -i video.mkv -i audio.m4a -vcodec copy -acodec copy OUTPUT
</code></pre>

<p>这样就成功了。把得到的 FLV 传到新浪视频，就可以给哔哩哔哩投稿了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Almost Done]]></title>
    <link href="http://jellyflower.github.io/blog/2012/03/17/almost-done/"/>
    <updated>2012-03-17T21:37:00-04:00</updated>
    <id>http://jellyflower.github.io/blog/2012/03/17/almost-done</id>
    <content type="html"><![CDATA[<p>Recently I&rsquo;ve been working on my program which is capable of automatically preparing movies and anime for the new iPad. I tried feeding Madoka&rsquo;s opening to my program and got a somewhat nice result. You can see that my program is able to render subtitles in ASS format using custom fonts, thanks to libass.</p>

<p><img src="/img/madoka-render.png" alt="Mahou Shoujo Madoka Magica" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Can I Use the New iPad 3 to Watch Movies and Anime?]]></title>
    <link href="http://jellyflower.github.io/blog/2012/03/08/can-i-use-the-new-ipad-3-to-watch-movies-and-anime/"/>
    <updated>2012-03-08T19:21:00-05:00</updated>
    <id>http://jellyflower.github.io/blog/2012/03/08/can-i-use-the-new-ipad-3-to-watch-movies-and-anime</id>
    <content type="html"><![CDATA[<iframe frameborder="0" height="200" src="https://docs.google.com/spreadsheet/pub?key=0As1rSZ9BFIoWdFRObTRnVW9WcmI4WmE1dUNEZ1NFVnc&amp;single=true&amp;gid=0&amp;output=html&amp;widget=true" width="800"></iframe>


<p>I compared the video standard supported by the new iPad 3 with Blu-ray and pirates. So basically, the rumor that iPad 3 can play Blu-ray is wrong. It supports neither demuxing M2TS nor decoding PCM, Dolby or DTS. For video, you don&rsquo;t want a huge file occupying all the space on your iPad which plays only an hour. So, it looks like we need to do a bit encoding and muxing work. I&rsquo;ll probably do some research on how to massively and automatically prepare movies for iPad 3 and share my way, depending on whether I will spend money on this great toy.</p>
]]></content>
  </entry>
  
</feed>
