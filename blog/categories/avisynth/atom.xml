<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Avisynth | The Place Where Wishes Come True]]></title>
  <link href="http://jellyflower.github.io/blog/categories/avisynth/atom.xml" rel="self"/>
  <link href="http://jellyflower.github.io/"/>
  <updated>2014-08-11T22:34:50-04:00</updated>
  <id>http://jellyflower.github.io/</id>
  <author>
    <name><![CDATA[Jellyflower]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to Use 64-bit X264 With 32-bit AviSynth]]></title>
    <link href="http://jellyflower.github.io/blog/2013/03/09/how-to-use-64-bit-x264-with-32-bit-avisynth/"/>
    <updated>2013-03-09T18:40:00-05:00</updated>
    <id>http://jellyflower.github.io/blog/2013/03/09/how-to-use-64-bit-x264-with-32-bit-avisynth</id>
    <content type="html"><![CDATA[<p>For some reason I had to use AviSynth 2.6, of which I could’t seem to find a 64-bit build. But I did’t want to use 32-bit x264, because the 64-bit version had much better performance on 64-bit machines.</p>

<p>After some research, I found avs2pipemod. avs2pipemod is a program that pipes the output of AviSynth to other programs, with which we are able to connect 64-bit x264 and 32-bit AviSynth.</p>

<p>Because we will be piping raw video, we have to specify the parameters of the video manually. Fortunately avs2pipemod is able to generate those arguments for us. First we execute the following command:</p>

<pre><code>avs2pipemod -x264raw SCRIPT.avs
</code></pre>

<p>And we will get something like this:</p>

<pre><code>- --demuxer raw --input-csp bgr --input-depth 8 --input-res 1920x1080 --output-csp rgb --frames 24429 --fps 30030/1001
</code></pre>

<p>Of course the values will change depending on your source. So now we can call x264 with those arguments</p>

<pre><code>avs2pipemod -rawvideo SCRIPT.avs | x264 - --demuxer raw --input-csp bgr --input-depth 8 --input-res 1920x1080 --frames 24429 --fps 30030/1001 --preset veryslow --crf 23 -o OUTPUT.mkv
</code></pre>

<p>It’s just copying the arguments generated by the first command, plus the arguments you would like to use for encoding.</p>

<p>For some reason when I tried this, I got my encoded video upside down. I am not quite clear what caused that. However the problem can be easily solved by changing the previous command a little bit:</p>

<pre><code>avs2pipemod -rawvideo=vflip SCRIPT.avs | ...
</code></pre>

<p>The x264 part remains the same. I only tried once, so I don’t know if this happens to just some or all videos. You definitely want to check your result to know if it is necessary for you to use vflip.</p>

<p>So far we’ve done the video part. For audio, use the following command:</p>

<pre><code>avs2pipemod -wav SCRIPT.avs | flac -8V -o OUTPUT.flac -
</code></pre>

<p>Here we are piping the audio in WAV format, therefore we don’t need to specify the parameters of the audio. Of course you can use whatever encoder you want.</p>

<p>Now just mux the two streams and you are good to go.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fraps Video Too Dark? How to: Decode Fraps Video Correctly]]></title>
    <link href="http://jellyflower.github.io/blog/2012/08/02/fraps-video-too-dark-how-to-decode-fraps-video-correctly/"/>
    <updated>2012-08-02T23:59:00-04:00</updated>
    <id>http://jellyflower.github.io/blog/2012/08/02/fraps-video-too-dark-how-to-decode-fraps-video-correctly</id>
    <content type="html"><![CDATA[<p>The video stream in the multimedia file recorded by Fraps is encoded in Fraps’ own codec. The color space of the video stream can be either YV12 or RGB24. There is an option in Fraps which lets you choose which color space to use.</p>

<p>Currently, many decoders fail to handle Fraps videos in the YV12 color space correctly, resulting in decoded pictures that appear very dark.</p>

<p>In either case, the video stream can be decoded correctly using AviSynth. For YV12, use:</p>

<pre><code>FFIndex(INPUT)
AudioDub(FFVideoSource(INPUT), FFAudioSource(INPUT))
ColorYUV(levels="PC-&gt;TV")
ColorMatrix(mode="rec.709-&gt;rec.601", clamp=0)
</code></pre>

<p>For RGB24, use:</p>

<pre><code>FFIndex(INPUT)
AudioDub(FFVideoSource(INPUT), FFAudioSource(INPUT))
</code></pre>

<p>Don’t use the following script:</p>

<pre><code>AviSource(INPUT)
</code></pre>

<p>That uses Fraps’ own decoder, which converts YV12 to RGB24. If you later encode the video to YV12, the whole process, YV12 → RGB24 → YV12, causes quality loss. In the above two scripts, there is no unnecessary color space conversion.</p>

<p>It is said that by using the right parameters, both FFmpeg and x264 can decode the video stream correctly. But I haven’t tried yet.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hardsubbing ASS Subtitles in AviSynth]]></title>
    <link href="http://jellyflower.github.io/blog/2012/03/11/hardsubbing-ass-subtitles-in-avisynth/"/>
    <updated>2012-03-11T00:27:00-05:00</updated>
    <id>http://jellyflower.github.io/blog/2012/03/11/hardsubbing-ass-subtitles-in-avisynth</id>
    <content type="html"><![CDATA[<p>I find that this job can be nicely done by <a href="http://srsfckn.biz/assrender/">assrender</a>, which is based on libass. It even renders karaoke well. Its usage will be like:</p>

<pre><code>LoadCPlugin("assrender.dll")
assrender("subtitles.ass", hinting=3, fontdir="font")
</code></pre>

<p>The fontdir option is a directory holding fonts used to render the subtitles, which you don&rsquo;t want to install on your system.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Frame-accurate Decoding and Frameserving of Video Inside AVI]]></title>
    <link href="http://jellyflower.github.io/blog/2012/03/11/frame-accurate-decoding-and-frameserving-of-video-inside-avi/"/>
    <updated>2012-03-11T00:13:00-05:00</updated>
    <id>http://jellyflower.github.io/blog/2012/03/11/frame-accurate-decoding-and-frameserving-of-video-inside-avi</id>
    <content type="html"><![CDATA[<p>Basically, AVI, MKV, MP4 and FLV are handled very well by <a href="http://code.google.com/p/ffmpegsource/">FFmpegSource2</a>. The script can be something like this:</p>

<pre><code>LoadCPlugin("ffms2.dll")
FFVideoSource("source.mkv")
</code></pre>

<p>Note that I&rsquo;m using the newer C plugin version.</p>

<p>For M2TS and TS, it seems that by far <a href="http://www.videohelp.com/tools/DGAVCDec">DGAVCDec</a> is the best choice. Use DGAVCIndex to index the source and you will get a DGA index file. Then write a script like this:</p>

<pre><code>LoadPlugin("DGAVCDecode.dll")
AVCSource("source.dga")
</code></pre>
]]></content>
  </entry>
  
</feed>
